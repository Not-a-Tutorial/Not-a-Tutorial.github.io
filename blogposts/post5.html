<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>
      a small blog
      </title>
    <link href="../stylesheet.css" rel="stylesheet"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <div class="paper">
     <div id="header-placeholder"></div>
       <main>  
         <section>
           <h1>How Long Does a Bingo Game Last on Average? A Summer of Math Exposition Submission</h1>
           <h2>Sep. 1, 2025</h2>
             <article>
               <h3>A Nagging Question</h3>
               <p>“How long does it take to win a game of bingo?” That’s the thought I had as I was calling my 20th bingo game at my annual family reunion. “The game has to have an average length, right? It definitely feels like it,” I thought as  I briskly roll the cage, filling the domed plastic sheet with each ball. “But how could I calculate that..?” After getting home, I got to work finding the solution. This is is an exploration into my process.</p>
               <h3>The Game</h3>
               <p>To answer any question about a game, we need to elaborate on its structure and rules. In Bingo, 	every player has a card with a 5x5 grid. They have the goal of creating a pattern on the grid by marking squares. The standard patterns are:</p>
               <ul>
                 <li>any row of 5,</li>
                 <li>any column of 5,</li>
                 <li>or either diagonal of 5.</li>
               </ul>
               <p>The center of the grid is considered “free,” such that ever player starts with that square marked. Every square besides the center is given a random number 1 thru 75; no number will show up on a card more than once. </p>
               <p>The game is run by a caller who has a tumbler filled with balls numbered 1 thru 75. Each round, the caller randomly pulls a ball from the tumbler and announces it to the players. If a player has the corresponding number on their card, the square with that number is marked. The ball removed by the caller is not returned to the tumbler. This continues until a player’s card meets one of the winning conditions.</p>
               <p>So… how long does it take for at least one player to meet a winning condition?</p>
               <h3>My Shame</h3>
               <p>Unfortunately, I’m not a mathematician by trade. Worse, I’m a former physicist turned businessman with a spreadsheet: something akin to a chimp with a machine gun. I know statistics, and a part of me feels like this can be done strictly on paper, but it’s no so clear to me. Given that, my first route was to simulate the solution. I’ll be using Python; the full code be viewed <a target="_blank" href="https://github.com/Not-a-Tutorial/Bingo/tree/main">thru this link</a>. Please be kind. </p>
               <h3>Permutations</h3>
               <p>It’s tempting to start by simulating the tumbler with generating a random number 1 thru 75. However, this isn’t accurate; if we do this, there will be a chance that the same number will be chosen twice. That would simulate the caller pulling a ball from the tumbler then placing it back inside. We want to simulate the caller pulling a number without replacement. In mathematics, this can be represented by a <a target="_blank" href="https://www.mathsisfun.com/combinatorics/combinations-permutations.html">permutation</a>. We can effectively generate the entire game’s pulls all at once for the simulation to run through. </p>
               <p>We can use permutations to generate our player’s card as well by making a new permutation and choosing the first 24 numbers to populate our array. (In a real bingo game, each column labeled with each letter of the word “Bingo” can only be of sets of 15 numbers. For example, the column “B” will only ever have five numbers from the set 1-15, column “I” only from the set 16-30, etc. While we could simulate the strictly, the answer would not materially change.)</p>
               <h3>Mapping a Board States</h3>
               <p>A bingo chard encodes two sets of values:</p>
               <ul>
                 <li>the array of numbers held in the grid that the player sees,</li>
                 <li>and whether or not the squares of the grid have been marked.</li>
               </ul>
               <p>I chose to create this mapping with two arrays, one which passes information to the other. The first array will hold the bingo card’s numbers. The second array would hold binary values, 0 or 1, for a square that is either not filled or filled, respectively. The secondary array will start with all zeros, except for the center, which will be initialized to 1, representing the standard free square. If a number is called and it appears on a players card, our program will note the location in our first array and mark that same location in the second array with a 1. This may not be the most efficient way to create this mapping, but it makes intuitive sense for me. I hope it does for you too. </p>
               <h3>Winning</h3>
               <p>Now, we’ll quickly throw together a way to check our second array to see if, after each call, a card has won. Looking ahead, we plan on doing hundreds or thousands of simulations. To save just a little processing time, the code will check first that the sum of the marked array is greater than 4. This will make sure the code doesn’t run through all of the win conditions for a card that couldn’t possibly win, since you need a minimum of 5 squares to be filled for a win.</p>
               <h3>The Loneliest Number</h3>
               <p>Now, we can run our simulation and see how many turns it takes to win a game when there is only one player participating. But, running it once...doesn’t help much. The number of turns to win will always be different! Let’s keep track of how many turns it takes for our single player to win a game of bingo and repeat the simulation a few… thousand times. The Law of Large Numbers says “the average of the results obtained from a large number of independent random samples converges to the true value, if it exists.”  Running this program over and over again, we can create a relative frequency histogram to visualize this convergent trend.</p>
               <p>Frequency analysis like this is an entire topic of its own, but we can quickly say two things about the diagram we have here. The mode of this distribution (the number that appears the most) is 42. So, a single player is most likely to play around 42 rounds before they meet a winning condition. The average is slightly lower at around 40.3. While it is tempting to use the mode of the distribution, the nature of our randomly generated simulation will cause it to vary quite a bit at lower simulation counts, so we’ll consider the average moving forward. </p>
               <h3>Let's Make Some Friends</h3>
               <p>I can’t imagine a lot of people play bingo by themselves. We’ve shown that it can be simulated in a completely probabilistic way, so playing solo would be the equivalent of <a target = "_blank" href="https://www.youtube.com/watch?v=917VgVGVkpc">flipping a coin over and over by yourself</a>. An interesting question may be: how does the average game length change as we increase the number of players? After all, at my family reunion, we had  various numbers of players at different times; would a game be longer or shorter with more people? We can run multiple simulations with different numbers of player cards and plot each scenarios’ average as a point along a segmented line. As we plot these points, a trend seems to form. </p>
               <img src="/photos/Rounds_Per_Player_Without_Trend.png" width="500px" alt="A Histogram Showing the Average Number of Rounds for a Single Player to Win a Bingo Game." class="center">
               <h3>Getting Fit</h3>
               <p>At this point, it’s tempting to ask: can we characterize the trend we are seeing here? This concept is called finding the best fit curve, and it is useful if we believe there is a function that describes our data. If there is a function that our points follow, it will allows us to predict the average game length of games we haven’t played without burning a hole in our CPU to simulate it. Though, there are limitations to this concept, namely: our resulting equation will be continuous, but we’re modeling an average number of turns in a bingo game, which can only be  positive integers. This is a good thing to remember when creating any best fit curve. Context always matters.</p>
               <p>To start, we need to choose an equation that’s a contender to fit our data. Let’s see if we can make a few observations about our data to narrow down what that equation might be:</p>
               <ul>
                 <li>The data decreases in y as x increases.</li>
                 <li>The slope of the data is steep for small values of x, and the slope becomes flatter for larger values of x.</li>
                 <li>It is possible that there is a vertical asymptote at x = 0. This can be explained as “a game with zero players will have an ‘infinite’ number of turns before there is a winner.”</li>
                 <li>It is possible that there is a horizontal asymptote at y = 4; this can be explained as “a game with infinitely many players will have the shortest game of bingo possible at 4 pulls. A win with four pulls will occur with any line that crosses through the free space at the center.”</li>
               </ul>
               <p>Whenever I am looking for a trend, I like to look up pictures of families of functions. There are a few candidates that would satisfy our observations, but I’m going to try y=1/x. This equation does decrease in y as x increases, and it does fall off quickly before leveling out. It also has a vertical and horizontal asymptote. I think this is a good starting point.</p>
               <p>With a candidate curve picked out, we want to generalize its equation to y = a*(x+b)^c+d. In this equation, b moves the curve left and right relative to the y-axis. We don’t need to do that, since there is currently a vertical asymptote at x = 0. So, we can set b to zero. Now, d will move our curve up and down relative to the x-axis. Since the standard curve has a horizontal asymptote at y = 0, we can set d = 4 so our horizontal asymptote will move up to y = 4.</p>
               <p>With only a and c remaining, let’s remember what x represents: the number of players in the game. We actually have a very good estimate for the average number of turns for a single player! It’s our average from earlier: 40.3. Plugging that into the equation: 40.3 = a*1^c. We know that 1 to any power c will always be 1, so a must equal 40.3. The only variable remaining is c. We’ve run out of clever tricks, so this last variable will need to be found using curve fitting function in Python which hunts for an optimal value with brute force. </p>
               <h3>Results and Conclusion</h3>
               <p><i>Et viola</i>, we get a really good fit! The average number of rounds of a standard game of Bingo can be described as:</p>
               <p>y = 40.3*x^0.2737 + 4 where x, the number of players, is a positive integer.</p>
               <p>And with this function, we can give the average count of any Bingo game. <a target = "_blank" href = "https://www.stat.berkeley.edu/~aldous/157/Old_Projects/chon.pdf">One paper that I found</a> by a student(?) at Berkeley named William Chon actually went one step further to calculate the number of near-miss games and went on to investigate the implications for those near-misses on running bingo games at casinos. Would recommend giving it a read.</p>
               <p>So, that’s it. We found a satisfying answer to our question. Starting by understanding our game, creating a set of rules. Then, we created a simulation that ran though games of various player counts. Using this data, we found a candidate best fit curve function to describe the data and used our fundamental understanding of the game to reduce the number of variables we needed to find.</p>
               <p>If this has gotten you interested in learning more about this kind of approach, MIT Opencourseware has <a target = "_blank" href = "https://www.youtube.com/playlist?list=PLUl4u3cNGP619EG1wp0kT-7rDE_Az5TNd">a good set of lectures describing simulations using random variables</a>. </p>
             </article>
         </section>
       </main>
      <div id="footer-placeholder"></div>
    </div>
    <script src="../header.js"></script>
  </body>
</html>
